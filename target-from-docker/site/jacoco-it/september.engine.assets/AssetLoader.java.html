<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AssetLoader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">september</a> &gt; <a href="index.source.html" class="el_package">september.engine.assets</a> &gt; <span class="el_source">AssetLoader.java</span></div><h1>AssetLoader.java</h1><pre class="source lang-java linenums">package september.engine.assets;

import org.lwjgl.BufferUtils;
import september.engine.rendering.Texture;
import september.engine.rendering.gl.Shader;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;

/**
 * A utility class for loading raw asset data from files.
 * This class handles the low-level details of reading files from the classpath
 * and supports parsing GLSL #include directives.
 */
public final class AssetLoader {

  // Private constructor to prevent instantiation of this utility class.
  private AssetLoader() {}

  /**
   * Loads a shader program by reading vertex and fragment shader source files.
   * This method recursively processes #include directives.
   * @param vertexPath   The classpath resource path to the vertex shader file.
   * @param fragmentPath The classpath resource path to the fragment shader file.
   * @return A new, compiled Shader object.
   */
  public static Shader loadShader(String vertexPath, String fragmentPath) {
<span class="nc" id="L32">    String vertexSource = loadShaderSourceWithIncludes(vertexPath);</span>
<span class="nc" id="L33">    String fragmentSource = loadShaderSourceWithIncludes(fragmentPath);</span>
<span class="nc" id="L34">    return new Shader(vertexSource, fragmentSource);</span>
  }

  /**
   * Loads a texture from an image file on the classpath.
   * @param filePath The classpath resource path to the image file.
   * @return A new Texture object.
   */
  public static Texture loadTexture(String filePath) {
    try {
<span class="fc" id="L44">      ByteBuffer imageBuffer = readResourceToByteBuffer(filePath);</span>
<span class="fc" id="L45">      return new Texture(imageBuffer);</span>
<span class="nc" id="L46">    } catch (IOException e) {</span>
<span class="nc" id="L47">      throw new RuntimeException(&quot;Failed to load texture resource: &quot; + filePath, e);</span>
    }
  }

  /**
   * Recursively loads a shader source file, processing #include directives.
   * @param filePath The classpath path to the shader file.
   * @return The complete shader source with all includes resolved.
   */
  private static String loadShaderSourceWithIncludes(String filePath) {
<span class="nc" id="L57">    String source = readResourceToString(filePath);</span>

    // Determine the base path for relative includes
<span class="nc" id="L60">    String basePath = &quot;&quot;;</span>
<span class="nc" id="L61">    int lastSlash = filePath.lastIndexOf('/');</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if (lastSlash != -1) {</span>
<span class="nc" id="L63">        basePath = filePath.substring(0, lastSlash + 1);</span>
    }

<span class="nc" id="L66">    StringBuilder finalSource = new StringBuilder();</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    for (String line : source.split(&quot;\\R&quot;)) { // Split by any newline sequence</span>
<span class="nc" id="L68">        String trimmedLine = line.trim();</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (trimmedLine.startsWith(&quot;#include&quot;)) {</span>
            // Extract path from quotes
<span class="nc" id="L71">            String includePath = trimmedLine.substring(trimmedLine.indexOf('&quot;') + 1, trimmedLine.lastIndexOf('&quot;'));</span>
            // Recursively load and append the included source
<span class="nc" id="L73">            finalSource.append(loadShaderSourceWithIncludes(basePath + includePath));</span>
<span class="nc" id="L74">            finalSource.append(System.lineSeparator());</span>
<span class="nc" id="L75">        } else {</span>
<span class="nc" id="L76">            finalSource.append(line).append(System.lineSeparator());</span>
        }
    }
<span class="nc" id="L79">    return finalSource.toString();</span>
  }

  /**
   * Reads a resource file from the classpath into a single String.
   * @param filePath The classpath resource path.
   * @return The contents of the file as a string.
   */
  private static String readResourceToString(String filePath) {
<span class="nc" id="L88">    try (InputStream is = AssetLoader.class.getClassLoader().getResourceAsStream(filePath)) {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">      if (is == null) {</span>
<span class="nc" id="L90">        throw new IOException(&quot;Resource not found: &quot; + filePath);</span>
      }
<span class="nc" id="L92">      return new String(is.readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="nc" id="L93">    } catch (IOException e) {</span>
<span class="nc" id="L94">      throw new RuntimeException(&quot;Failed to read resource: &quot; + filePath, e);</span>
    }
  }

  private static ByteBuffer resizeBuffer(ByteBuffer buffer, int newCapacity) {
<span class="fc" id="L99">    ByteBuffer newBuffer = BufferUtils.createByteBuffer(newCapacity);</span>
<span class="fc" id="L100">    buffer.flip();</span>
<span class="fc" id="L101">    newBuffer.put(buffer);</span>
<span class="fc" id="L102">    return newBuffer;</span>
  }

  /**
   * Reads a resource file from the classpath into a direct ByteBuffer.
   * This method reads the resource in chunks and is robust for use inside JARs.
   * @param filePath The classpath resource path.
   * @return A ByteBuffer containing the file data.
   */
  public static ByteBuffer readResourceToByteBuffer(String filePath) throws IOException {
<span class="fc" id="L112">    InputStream source = AssetLoader.class.getClassLoader().getResourceAsStream(filePath);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">    if (source == null) {</span>
<span class="nc" id="L114">        throw new IOException(&quot;Resource not found: &quot; + filePath);</span>
    }

<span class="fc" id="L117">    int bufferSize = 8192;</span>
<span class="fc" id="L118">    ByteBuffer buffer = BufferUtils.createByteBuffer(bufferSize);</span>

<span class="fc" id="L120">    try (ReadableByteChannel rbc = Channels.newChannel(source)) {</span>
      while (true) {
<span class="fc" id="L122">        int bytes = rbc.read(buffer);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (bytes == -1) {</span>
<span class="fc" id="L124">          break;</span>
        }
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (buffer.remaining() == 0) {</span>
<span class="fc" id="L127">          buffer = resizeBuffer(buffer, buffer.capacity() * 2);</span>
        }
<span class="fc" id="L129">      }</span>
    }

<span class="fc" id="L132">    buffer.flip();</span>
<span class="fc" id="L133">    return buffer;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>